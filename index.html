<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=0.55">
  <link rel="manifest" href="manifest.json">
  <link rel="serviceworker" href="/sw.js">
  <meta charset="utf-8">
  <meta name="viewport" content="user-scalable=no, initial-scale=1">
  <title>A-maze-ing</title>
</head>

<template id="maze-view">
  <style>
    :host {
      width: 100vh;
      height: 100vh;
    }

    canvas {
      margin: 16px;
    }
  </style>
  <canvas id="canvas" width="800" height="800"></canvas>
</template>

<script>
  function toEulerianAngle(quat, out)
  {
    const ysqr = quat[1] ** 2;

    // Roll (x-axis rotation).
    const t0 = 2 * (quat[3] * quat[0] + quat[1] * quat[2]);
    const t1 = 1 - 2 * (ysqr + quat[0] ** 2);
    out[0] = Math.atan2(t0, t1);

    // Pitch (y-axis rotation).
    let t2 = 2 * (quat[3] * quat[1] - quat[2] * quat[0]);
    t2 = t2 > 1 ? 1 : t2;
    t2 = t2 < -1 ? -1 : t2;
    out[1] = Math.asin(t2);

    // Yaw (z-axis rotation).
    const t3 = 2 * (quat[3] * quat[2] + quat[0] * quat[1]);
    const t4 = 1 - 2 * (ysqr + quat[2] ** 2);
    out[2] = Math.atan2(t3, t4);

    return out;
  }

  class InclinationSensor {
    constructor() {
      const sensor = new AbsoluteOrientationSensor({ frequency: 30 });
      const mat4 = new Float32Array(16);
      const euler = new Float32Array(3);

      sensor.onchange = () => {
        sensor.populateMatrix(mat4);
        toEulerianAngle(sensor.quaternion, euler);
        this.roll = euler[0];
        this.pitch = euler[1];

        if (this.onchange) this.onchange();
      };

      sensor.start();
    }
  }

  customElements.define('maze-view', class extends HTMLElement {
    constructor() {
      super();
      const template = document.querySelector('#maze-view');
      const clone = document.importNode(template.content, true);
      const shadowRoot = this.attachShadow({ mode: 'open' });
      shadowRoot.appendChild(clone);

      this.prevX = this.x = 0;
      this.prevY = this.y = 135;
    }

    connectedCallback() {
      this.canvasEl = this.shadowRoot.querySelector('#canvas');
      this.context = this.canvasEl.getContext("2d");

      const width = window.screen.availWidth - 16 * 2;
      this.canvasEl.style.width = width;
      this.canvasEl.style.height = width;

      this.image = new Image();
      this.image.src = "levels/maze2.gif";
      this.image.onload = _ => {
        this.canvasEl.width = this.image.width;
        this.canvasEl.height = this.image.height;
        this.clear();
      }

      const sensor = new InclinationSensor();
      sensor.onchange = () => {
        this.roll = sensor.roll;
        this.pitch = sensor.pitch;
      }

      this.render();
    }

    collides() {
      const rgbaData = this.context.getImageData(this.x, this.y, 16, 16).data;

      for (let i = 0; i < rgbaData.length; i += 4) {
        if (rgbaData[i] == 0) {
          return true;
        }
      }

      return false;
    }

    clear() {
      this.context.clearRect(0, 0, this.canvasEl.width, this.canvasEl.height);
      this.context.drawImage(this.image, 0, 0);
    }

    render() {
      // Take a sample, we might be slow at calculating.
      const roll = Math.round(this.roll * 10);
      const pitch = Math.round(this.pitch * 10);

      if (Math.abs(roll) >= 1) {
        this.y += roll;
        while (this.collides()) {
          this.y -= Math.sign(roll);
        }
      }

      if (Math.abs(pitch) >= 1) {
        this.x += pitch;
        while (this.collides()) {
          this.x -= Math.sign(pitch);
        }
      }

      this.context.clearRect(this.prevX, this.prevY, 16, 16);
      this.clear();

      this.context.fillStyle = "purple";

      this.context.beginPath();
      this.context.rect(this.x, this.y, 16, 16);
      this.context.closePath();
      this.context.fill();

      this.prevX = this.x;
      this.prevY = this.y;

      requestAnimationFrame(() => this.render());
    }
  });
</script>

<style>
  body {
    margin: 0px;
  }
</style>
<body>
  <maze-view></maze-view>
</body>
</html>
